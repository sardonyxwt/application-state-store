(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("store", [], factory);
	else if(typeof exports === 'object')
		exports["store"] = factory();
	else
		root["store"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var object_1 = __webpack_require__(1);
var generator_1 = __webpack_require__(2);
var synchronized_1 = __webpack_require__(3);
var ScopeImpl = /** @class */ (function () {
    function ScopeImpl(name, state) {
        this.name = name;
        this.state = state;
        this.isFrozen = false;
        this.actions = {};
        this.listeners = {};
    }
    ScopeImpl.prototype.registerAction = function (name, action) {
        if (this.isFrozen) {
            throw new Error("This scope is locked you can't add new action.");
        }
        if (name in this.actions) {
            throw new Error("Action name is duplicate in scope " + this.name);
        }
        this.actions[name] = action;
    };
    ScopeImpl.prototype.dispatch = function (actionName, props) {
        var _this = this;
        var action = this.actions[actionName];
        if (!action) {
            throw new Error("This action not exists " + actionName);
        }
        if (props && typeof props === 'object') {
            object_1.deepFreeze(props);
        }
        var oldState = this.state;
        return new Promise(function (resolve, reject) {
            action(oldState, props, resolve, reject);
        }).then(function (newState) {
            object_1.deepFreeze(newState);
            Object.getOwnPropertyNames(_this.listeners).forEach(function (key) { return _this.listeners[key]({ oldState: oldState, newState: newState, actionName: actionName, props: props }); });
            _this.state = newState;
            return newState;
        });
    };
    ScopeImpl.prototype.subscribe = function (listener, actionName) {
        if (actionName && !(actionName in this.actions)) {
            throw new Error("Action (" + actionName + ") not present in scope.");
        }
        var listenerId = generator_1.uniqueId('listener');
        this.listeners[listenerId] = function (event) {
            if (!actionName || actionName === event.actionName) {
                listener(event);
            }
        };
        return listenerId;
    };
    ScopeImpl.prototype.synchronize = function (object, key, actionName) {
        object[key] = this.getState();
        return this.subscribe(function (_a) {
            var newState = _a.newState;
            object[key] = newState;
        }, actionName);
    };
    ScopeImpl.prototype.unsubscribe = function (id) {
        return delete this.listeners[id];
    };
    ScopeImpl.prototype.lock = function () {
        this.isFrozen = true;
    };
    ScopeImpl.prototype.isLocked = function () {
        return this.isFrozen;
    };
    ScopeImpl.prototype.getState = function () {
        return this.state;
    };
    ScopeImpl.prototype.getSupportActions = function () {
        return Object.getOwnPropertyNames(this.actions);
    };
    return ScopeImpl;
}());
var ComposeScopeImpl = /** @class */ (function (_super) {
    __extends(ComposeScopeImpl, _super);
    function ComposeScopeImpl(name, scopes) {
        var _this = _super.call(this, name, {}) || this;
        _this.name = name;
        _this.scopes = scopes;
        var actionNames = [];
        scopes.forEach(function (scope) {
            scope.lock();
            actionNames = actionNames.concat(scope.getSupportActions());
        });
        actionNames = actionNames.filter(function (actionName, i, self) { return self.indexOf(actionName) === i; });
        actionNames.forEach(function (actionName) { return _this.registerAction(actionName, function (state, props, resolve, reject) {
            var dispatchPromises = scopes.filter(function (scope) { return scope.getSupportActions().findIndex(function (it) { return it === actionName; }) >= 0; }).map(function (scope) { return scope.dispatch(actionName, props); });
            synchronized_1.syncPromises(dispatchPromises).then(function () { return resolve(_this.getState()); }).catch(reject);
        }); });
        _this.lock();
        return _this;
    }
    ComposeScopeImpl.prototype.getState = function () {
        var state = {};
        this.scopes.forEach(function (scope) { return state[scope.name] = scope.getState(); });
        return state;
    };
    return ComposeScopeImpl;
}(ScopeImpl));
var scopes = {};
/**
 * Create a new scope and return it.
 * @param {string} name The name of scope.
 * @default Generate unique name.
 * @param {any} initState The initial scope state.
 * By default use empty object.
 * @return {Scope} Scope.
 * @throws {Error} Will throw an error if name of scope not unique.
 */
function createScope(name, initState) {
    if (name === void 0) { name = generator_1.uniqueId('scope'); }
    if (initState === void 0) { initState = null; }
    if (name in scopes) {
        throw new Error("Scope name must unique");
    }
    var scope = new ScopeImpl(name, initState);
    scopes[name] = scope;
    return scope;
}
exports.createScope = createScope;
/**
 * Compose a new scope and return it.
 * @description All scopes is auto lock.
 * @param {string} name The name of scope
 * @param {(Scope | string)[]} scopes Scopes to compose.
 * Length must be greater than one
 * @return {Scope} Compose scope.
 * @throws {Error} Will throw an error if scopes length less fewer than two.
 * @throws {Error} Will throw an error if name of scope not unique.
 */
function composeScope(name, scopes) {
    if (name in scopes) {
        throw new Error("Scope name must unique");
    }
    var composeScopes = scopes.map(function (scope) { return typeof scope === "string" ? getScope(scope) : scope; }).filter(function (scope, i, self) { return scope && self.indexOf(scope) === i; });
    var MIN_COMPOSE_SCOPE_COUNT = 2;
    if (composeScopes.length < MIN_COMPOSE_SCOPE_COUNT) {
        throw new Error("Compose scopes length must be greater than one");
    }
    var scope = new ComposeScopeImpl(name, composeScopes);
    scopes[name] = scope;
    return scope;
}
exports.composeScope = composeScope;
/**
 * Returns scope.
 * @param {string} scopeName Name scope, to get the Scope.
 * @return {Scope} Scope
 * @throws {Error} Will throw an error if scope not present.
 */
function getScope(scopeName) {
    if (!scopes[scopeName]) {
        throw new Error("Scope with name " + scopeName + " not present");
    }
    return scopes[scopeName];
}
exports.getScope = getScope;
/**
 * Returns all scope states.
 * @return {{string: any}} Scope states
 */
function getState() {
    var state = {};
    Object.getOwnPropertyNames(scopes).forEach(function (key) {
        state[key] = scopes[key].getState();
    });
    return state;
}
exports.getState = getState;
/**
 * This scope is global
 * @type {Scope}
 */
exports.ROOT_SCOPE = createScope('rootScope', {});


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}("undefined"!=typeof self?self:this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=3)}({3:function(e,t,n){"use strict";function r(e){return Object.getOwnPropertyNames(e).forEach(function(t){var n=e[t];"object"==typeof n&&null!==n&&r(n)}),Object.freeze(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.deepFreeze=r}})});
//# sourceMappingURL=object.min.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}("undefined"!=typeof self?self:this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=1)}([,function(e,t,n){"use strict";function r(e){for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",n=[];n.length<e;)n.push(t.charAt(Math.floor(Math.random()*t.length)));return n}function o(e,t){void 0===e&&(e=""),void 0===t&&(t=!1),u[e]?++u[e]:u[e]=0;var n=e+u[e];return t&&(n=n+"-"+r(8).join("")),n}Object.defineProperty(t,"__esModule",{value:!0});var u={};t.generateSeed=r,t.uniqueId=o}])});
//# sourceMappingURL=generator.min.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}("undefined"!=typeof self?self:this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=4)}({4:function(e,t,n){"use strict";function r(e){return new i(e)}function o(e){return Promise.all(e.map(function(e){return Promise.resolve(e)}))}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e){this.action=e,this.cache={}}return e.prototype.get=function(e){if(e in this.cache)return this.cache[e];var t=this.action(e);return this.cache[e]=t,t},e.prototype.has=function(e){return e in this.cache},e.prototype.remove=function(e){var t=this,n=this.has(e);return n&&this.get(e).then(function(){return delete t.cache[e]}),n},e}();t.createSyncCache=r,t.syncPromises=o}})});
//# sourceMappingURL=synchronized.min.js.map

/***/ })
/******/ ]);
});
//# sourceMappingURL=state-store.min.js.map